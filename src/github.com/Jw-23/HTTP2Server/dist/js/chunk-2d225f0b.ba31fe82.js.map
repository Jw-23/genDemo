{"version":3,"sources":["webpack:///./src/mdConfig/catalog/0.js","webpack:///./src/mdConfig/catalog/1.js","webpack:///./src/mdConfig/catalog/2.js","webpack:///./src/mdConfig/main.js"],"names":["index","title","tag","lang","display","content","articleList","push","a0","a1","a2"],"mappings":"gHAAe,OACXA,MAAO,EACPC,MAAO,UACPC,IAAK,CAAC,OAAQ,QACdC,KAAM,OACNC,QAAS,oKAITC,QAAS,ohLCTE,GACXL,MAAO,EACPC,MAAO,eACPC,IAAK,CAAC,SAAU,QAChBC,KAAM,SACNC,QAAS,oMAWTC,QAAS,8mbChBE,GACXL,MAAO,EACPC,MAAO,QACPC,IAAK,CAAC,OAAQ,MAAM,OACpBC,KAAM,OACNC,QAAS,4KAITC,QAAS,usPCNb,MAAMC,EAAc,GACpBA,EAAYC,KAAKC,GACjBF,EAAYC,KAAKE,GACjBH,EAAYC,KAAKG,GACFJ","file":"js/chunk-2d225f0b.ba31fe82.js","sourcesContent":["export default {\r\n    index: 0,\r\n    title: \"猴子选大王问题\",\r\n    tag: [\"java\", \"base\"],\r\n    lang: \"java\",\r\n    display: \"n个猴子围成一圈，从编号为k的开始报数1-2-m-1-2-m-……报“m”的猴子就被淘汰，游戏一直进行到圈内只剩一只猴子它就是猴大王了。 想了很长时间不会,问了@Spider-gty，得知用两个一维数组模拟圈可以解决，下面是代码：\" +\r\n        \"<div>\\n\" +\r\n        \"    <hello-world></hello-world>\\n\" +\r\n        \"</div>\",\r\n    content: \"n个猴子围成一圈，从编号为k的开始报数1-2-m-1-2-m-……报“m”的猴子就被淘汰，游戏一直进行到圈内只剩一只猴子它就是猴大王了。\\n\" +\r\n        \"想了很长时间不会,问了@Spider-gty，得知用两个一维数组模拟圈可以解决，下面是代码：\\n\" +\r\n        \"```java\\n\" +\r\n        \"class MonkeyProblem \\n\" +\r\n        \"{\\n\" +\r\n        \"\\tpublic static void main(String[] args) \\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\tint k=17;\\n\" +\r\n        \"\\t\\tint[] last=new int[k+1];\\n\" +\r\n        \"\\t\\tint[] next=new int[k+1];\\n\" +\r\n        \"\\t\\tlast[1]=k;next[1]=2;\\n\" +\r\n        \"\\t\\tlast[k]=k-1;next[k]=1;\\n\" +\r\n        \"\\t\\tfor(int i=2;i<=k-1;i++)\\n\" +\r\n        \"\\t\\t{\\n\" +\r\n        \"\\t\\t\\tlast[i]=i-1;\\n\" +\r\n        \"\\t\\t    next[i]=i+1;\\n\" +\r\n        \"\\t\\t}\\n\" +\r\n        \"\\t    \\n\" +\r\n        \"\\t\\tint result=solve(last,next,1,10);\\n\" +\r\n        \"\\t\\tSystem.out.println(result);\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"    //  Find the correct monkey;\\n\" +\r\n        \"    //模拟报数过程\\n\" +\r\n        \"\\tstatic int count(int[] l,int[] n,int k,int m)\\n\" +\r\n        \"\\t\\t//l是上一个，n是下一个，k是某位置开始，m是往下数多少位\\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\t \\n\" +\r\n        \"         if(m==1) return  k;\\n\" +\r\n        \"         k=n[k];\\n\" +\r\n        \"         return count(l,n,k,m-1);\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"\\t//模拟淘汰过程，opted指被选中报到m的猴子\\n\" +\r\n        \"\\tstatic void eliminate(int[] l,int[] n,int opted)\\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\tn[l[opted]]=n[opted];\\n\" +\r\n        \"\\t\\tl[n[opted]]=l[opted];\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"\\tstatic int solve(int[] l,int[] n,int k ,int m)\\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\tif(n[k]==k) return k;\\n\" +\r\n        \"\\t\\tint opted=count(l,n,k,m);\\n\" +\r\n        \"\\t\\teliminate(l,n,opted);\\n\" +\r\n        \"\\t\\tint next=n[opted];\\n\" +\r\n        \"\\t\\treturn solve(l,n,next,m);\\n\" +\r\n        \"\\t}\\t\\n\" +\r\n        \"}\\n\" +\r\n        \"```\\n\" +\r\n        \"···························································································\\n\" +\r\n        \"事实上，过多的使用递归会影响程序的性能；按照这个思路，程序可以简化。\\n\" +\r\n        \"C++版本:\\n\" +\r\n        \"\\n\" +\r\n        \"```c++\\n\" +\r\n        \"#include <iostream>\\n\" +\r\n        \"\\n\" +\r\n        \"void initialize(int *last, int *next, int length);\\n\" +\r\n        \"\\n\" +\r\n        \"int solve(int *, int *, int &, int &);\\n\" +\r\n        \"\\n\" +\r\n        \"int main() {\\n\" +\r\n        \"    std::cout<<\\\"输入猴子的数量:\\\"<<std::endl;\\n\" +\r\n        \"    int monkey_mount;\\n\" +\r\n        \"    std::cin>>monkey_mount;\\n\" +\r\n        \"    int ls[monkey_mount];\\n\" +\r\n        \"    int nt[monkey_mount];\\n\" +\r\n        \"    initialize(ls, nt, monkey_mount);\\n\" +\r\n        \"    int startMonkey = 0;\\n\" +\r\n        \"    int epoch_length = 8;\\n\" +\r\n        \"    std::cout << solve(ls, nt, startMonkey, epoch_length) << std::endl;\\n\" +\r\n        \"\\treturn 0;\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"void initialize(int *last, int *next, int length) {\\n\" +\r\n        \"    for (int i = 1; i < length - 1; ++i) {\\n\" +\r\n        \"        last[i] = i - 1;\\n\" +\r\n        \"        next[i] = i + 1;\\n\" +\r\n        \"    }\\n\" +\r\n        \"    last[0] = length - 1;\\n\" +\r\n        \"    next[0] = 1;\\n\" +\r\n        \"    last[length - 1] = length - 2;\\n\" +\r\n        \"    next[length - 1] = 0;\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"int solve(int *last, int *next, int &startMonkey, int &epoch_length) {\\n\" +\r\n        \"    int monkey = startMonkey;\\n\" +\r\n        \"    while (next[monkey] != monkey) {\\n\" +\r\n        \"        for (int i = 1; i < epoch_length; i++)\\n\" +\r\n        \"            monkey = next[monkey];\\n\" +\r\n        \"        next[last[monkey]] = next[monkey];\\n\" +\r\n        \"        last[next[monkey]] = last[monkey];\\n\" +\r\n        \"        printf(\\\"本轮淘汰第%d个猴\\\\n\\\", monkey);\\n\" +\r\n        \"        monkey = next[monkey];\\n\" +\r\n        \"    }\\n\" +\r\n        \"    return monkey;\\n\" +\r\n        \"}\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"node版本\\n\" +\r\n        \"\\n\" +\r\n        \"```js\\n\" +\r\n        \"const readline = require('readline').createInterface({\\n\" +\r\n        \"    input: process.stdin,\\n\" +\r\n        \"    output: process.stdout\\n\" +\r\n        \"})\\n\" +\r\n        \"readline.question(\\\"输入猴子的数量\\\\n\\\", answer => {\\n\" +\r\n        \"    let next = [];\\n\" +\r\n        \"    let last = [];\\n\" +\r\n        \"    initialize(last, next, answer)\\n\" +\r\n        \"    console.log(`最终的猴子王是${solve(last, next, 0, answer)}`)\\n\" +\r\n        \"})\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"function initialize(last, next, length) {\\n\" +\r\n        \"    for (let i = 1; i < length - 1; i++) {\\n\" +\r\n        \"        last[i] = i - 1;\\n\" +\r\n        \"        next[i] = i + 1;\\n\" +\r\n        \"    }\\n\" +\r\n        \"    last[0] = length - 1;\\n\" +\r\n        \"    next[0] = 1;\\n\" +\r\n        \"    last[length - 1] = length - 2;\\n\" +\r\n        \"    next[length - 1] = 0;\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"function solve(last, next, startMonkey, epoch_length) {\\n\" +\r\n        \"    let monkey = startMonkey;\\n\" +\r\n        \"    while (next[monkey] !== monkey) {\\n\" +\r\n        \"        for (let i = 1; i < epoch_length; i++)\\n\" +\r\n        \"            monkey = next[monkey];\\n\" +\r\n        \"        next[last[monkey]] = next[monkey];\\n\" +\r\n        \"        last[next[monkey]] = last[monkey];\\n\" +\r\n        \"        console.log(`本轮淘汰第${monkey}个猴子`)\\n\" +\r\n        \"        monkey = next[monkey];\\n\" +\r\n        \"    }\\n\" +\r\n        \"    return monkey;\\n\" +\r\n        \"}\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"Go语言版:\\n\" +\r\n        \"\\n\" +\r\n        \"```go\\n\" +\r\n        \"package main\\n\" +\r\n        \"\\n\" +\r\n        \"import (\\n\" +\r\n        \"\\t\\\"bufio\\\"\\n\" +\r\n        \"\\t\\\"fmt\\\"\\n\" +\r\n        \"\\t\\\"os\\\"\\n\" +\r\n        \"\\t\\\"strconv\\\"\\n\" +\r\n        \")\\n\" +\r\n        \"\\n\" +\r\n        \"func main() {\\n\" +\r\n        \"\\tfmt.Printf(\\\"输入猴子的数量:\\\\n\\\")\\n\" +\r\n        \"\\tscanner := bufio.NewScanner(os.Stdin)\\n\" +\r\n        \"\\tscanner.Scan()\\n\" +\r\n        \"\\tmonkeyMount, _ := strconv.Atoi(scanner.Text())\\n\" +\r\n        \"\\tfmt.Printf(\\\"输入起始猴子的位置(从0开始):\\\\n\\\")\\n\" +\r\n        \"\\tscanner.Scan()\\n\" +\r\n        \"\\tstartMonkey, _ := strconv.Atoi(scanner.Text())\\n\" +\r\n        \"\\tfmt.Printf(\\\"输入猴子数数的步长:\\\\n\\\")\\n\" +\r\n        \"\\tscanner.Scan()\\n\" +\r\n        \"\\tepochStep, _ := strconv.Atoi(scanner.Text())\\n\" +\r\n        \"\\tlast := make([]int, monkeyMount, monkeyMount)\\n\" +\r\n        \"\\tnext := make([]int, monkeyMount, monkeyMount)\\n\" +\r\n        \"\\tinitialize(last, next, monkeyMount)\\n\" +\r\n        \"\\tfmt.Printf(\\\"最终的猴子王是%d\\\", solve(last, next, startMonkey, epochStep))\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"func initialize(last []int, next []int, length int) {\\n\" +\r\n        \"\\tfor i := 1; i < length-1; i++ {\\n\" +\r\n        \"\\t\\tlast[i] = i - 1\\n\" +\r\n        \"\\t\\tnext[i] = i + 1\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"\\tlast[0] = length - 1\\n\" +\r\n        \"\\tnext[0] = 1\\n\" +\r\n        \"\\tlast[length-1] = length - 2\\n\" +\r\n        \"\\tnext[length-1] = 0\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"func solve(last []int, next []int, startMonkey int, epochLength int) int {\\n\" +\r\n        \"\\tmonkey := startMonkey\\n\" +\r\n        \"\\tfor monkey != next[monkey] {\\n\" +\r\n        \"\\t\\tfor i := 1; i < epochLength; i++ {\\n\" +\r\n        \"\\t\\t\\tmonkey = next[monkey]\\n\" +\r\n        \"\\t\\t}\\n\" +\r\n        \"\\t\\tnext[last[monkey]] = next[monkey]\\n\" +\r\n        \"\\t\\tlast[next[monkey]] = last[monkey]\\n\" +\r\n        \"\\t\\tfmt.Printf(\\\"本轮淘汰第%d个猴子\\\\n\\\", monkey)\\n\" +\r\n        \"\\t\\tmonkey = next[monkey]\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"\\treturn monkey\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"```\\n\" +\r\n        \"最简单是当然是kotlin\\n\" +\r\n        \"\\n\" +\r\n        \"```kotlin\\n\" +\r\n        \"package com.wang.binarySearch\\n\" +\r\n        \"\\n\" +\r\n        \"import java.util.*\\n\" +\r\n        \"\\n\" +\r\n        \"fun main() {\\n\" +\r\n        \"    val scanner = Scanner(System.`in`)\\n\" +\r\n        \"    println(\\\"猴子的数量为:\\\")\\n\" +\r\n        \"    val monkeyMount = scanner.nextInt()\\n\" +\r\n        \"    println(\\\"猴子开始数数位置为:\\\")\\n\" +\r\n        \"    val startMonkey = scanner.nextInt()\\n\" +\r\n        \"    println(\\\"猴子数数的步长是:\\\")\\n\" +\r\n        \"    val countStep = scanner.nextInt()\\n\" +\r\n        \"    val last = Array(monkeyMount) { i: Int -> if (i == 0) monkeyMount - 1 else i - 1 }\\n\" +\r\n        \"    val next = Array(monkeyMount) { i: Int -> if (i == monkeyMount - 1) 0 else i + 1 }\\n\" +\r\n        \"    println(\\\"猴子王是:${solve(last, next, startMonkey, countStep)}\\\")\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"fun solve(last: Array<Int>, next: Array<Int>, startMonkey: Int, epochLength: Int): Int {\\n\" +\r\n        \"    var monkey = startMonkey\\n\" +\r\n        \"    while (monkey != next[monkey]) {\\n\" +\r\n        \"        repeat(epochLength - 1) { monkey = next[monkey] }\\n\" +\r\n        \"        last[next[monkey]] = last[monkey]\\n\" +\r\n        \"        next[last[monkey]] = next[monkey]\\n\" +\r\n        \"        println(\\\"本轮淘汰第 $monkey 个猴子\\\")\\n\" +\r\n        \"        monkey = next[monkey]\\n\" +\r\n        \"    }\\n\" +\r\n        \"    return monkey\\n\" +\r\n        \"}\\n\" +\r\n        \"```\\n\"\r\n}","export default {\r\n    index: 1,\r\n    title: \"Matplotlib绘图\",\r\n    tag: [\"python\", \"base\"],\r\n    lang: \"python\",\r\n    display: \"Matplotlib的绘图功能\\n\" +\r\n        \"@TOC\\n\" +\r\n        \"\\n\" +\r\n        \"1.条形图\\n\" +\r\n        \"import matplotlib.pyplot as plt\\n\" +\r\n        \"\\n\" +\r\n        \"data = [5, 20, 15, 25, 10]\\n\" +\r\n        \"\\n\" +\r\n        \"plt.bar(range(len(data)), data)\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"bar(left, height, width=0.8, bottom=None, **kwargs)\",\r\n    content: \"\\n\" +\r\n        \"\\n\" +\r\n        \"# Matplotlib的绘图功能\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"</font>\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"@[TOC](文章目录)\\n\" +\r\n        \"\\n\" +\r\n        \"## 1.条形图\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"import matplotlib.pyplot as plt\\n\" +\r\n        \"\\n\" +\r\n        \"data = [5, 20, 15, 25, 10]\\n\" +\r\n        \"\\n\" +\r\n        \"plt.bar(range(len(data)), data)\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"bar(left, height, width=0.8, bottom=None, **kwargs)\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"![在这里插入图片描述](https://img-blog.csdnimg.cn/20201118001059567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ3MjAyNTE4,size_16,color_FFFFFF,t_70#pic_center)\\n\" +\r\n        \"\\n\" +\r\n        \"可以通过增加关键字对条形图进行修饰：\\n\" +\r\n        \"\\n\" +\r\n        \"1. 颜色\\n\" +\r\n        \"\\n\" +\r\n        \"   facecolor(或fc)：用于设置柱体的颜色\\n\" +\r\n        \"\\n\" +\r\n        \"   通过 color 关键字参数 可以一次性设置多个颜色，color是一个数组\\n\" +\r\n        \"\\n\" +\r\n        \"2. 描边\\n\" +\r\n        \"\\n\" +\r\n        \"   - edgecolor 或 ec：描边的颜色，如white,black,blue\\n\" +\r\n        \"   - linestyle 或 ls:   描边的样式，如 \\\"-\\\" , \\\"--\\\";\\n\" +\r\n        \"   - linewidth 或 lw:描边的宽度 ：\\n\" +\r\n        \"\\n\" +\r\n        \"3. 填充\\n\" +\r\n        \"\\n\" +\r\n        \"   hatch ：hatch的值用于设置填充条形图的图形，如 \\\"X\\\", \\\"o\\\" ,\\\"/\\\" ;\\n\" +\r\n        \"\\n\" +\r\n        \"   ==注意：hatch的长个数表示填充的密度，如\\\"////////\\\"表示用\\\"/\\\"密集得填充==\\n\" +\r\n        \"\\n\" +\r\n        \"4. 误差线\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   yerr： 定义误差的浮动的绝对值\\n\" +\r\n        \"   error_kw: 误差线关键字，是一个字典\\n\" +\r\n        \"   关键字有：\\n\" +\r\n        \"   ecolor:误差线的颜色\\n\" +\r\n        \"   elinewidth: 误差线的宽度，即粗细\\n\" +\r\n        \"   capsize: 误差线帽子的长度\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"   \\n\" +\r\n        \"\\n\" +\r\n        \"5. 图例位置\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   pyplot.legend(**ky)\\n\" +\r\n        \"   \\n\" +\r\n        \"   #loc: 可选'best','upper left','bottom right' 等\\n\" +\r\n        \"   #bbox_to_anchor=(0.2, 1),以左下角为为原点，调整位置\\n\" +\r\n        \"   #bbox_transform=ax.transAxes\\n\" +\r\n        \"   #frameon: 图例是否有边框\\n\" +\r\n        \"   #下面的操作由于修改边框的颜色\\n\" +\r\n        \"   leg = plt.legend()\\n\" +\r\n        \"   leg.get_frame().set_edgecolor('b') \\n\" +\r\n        \"   \\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"6. 合并图例\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   #得到坐标轴1图例的句柄和标签值\\n\" +\r\n        \"   handles_1, labels_1 = ax1.get_legend_handles_labels()\\n\" +\r\n        \"   #得到坐标轴2图例的句柄和标签值\\n\" +\r\n        \"   handles_2, labels_2 = ax2.get_legend_handles_labels()\\n\" +\r\n        \"   #关键字传入,传入label（一个数组）参数可以改变图例的标签值\\n\" +\r\n        \"   plt.legend(handles=handles_1 + handles_2, bbox_to_anchor=(0.1, 1))\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"7. 设置刻度线标签（tick label）\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   import matplotlib.pyplot as plt\\n\" +\r\n        \"   \\n\" +\r\n        \"   data = [5, 20, 15, 25, 10]\\n\" +\r\n        \"   labels = ['Tom', 'Dick', 'Harry', 'Slim', 'Jim']\\n\" +\r\n        \"   \\n\" +\r\n        \"   plt.bar(range(len(data)), data, tick_label=labels)\\n\" +\r\n        \"   plt.show()\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"   ![img](https://img-blog.csdnimg.cn/img_convert/e57e86d46c213253314d581b86f04f87.png)\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"示例：\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"import matplotlib.pyplot as plt\\n\" +\r\n        \"\\n\" +\r\n        \"labels = [0.3, 0.5, 1.0, 1.5, 3.0]\\n\" +\r\n        \"bottom_means = [20, 80, 160, 250, 400]\\n\" +\r\n        \"top_means = [210, 250, 1200, 1500, 2600]\\n\" +\r\n        \"top_std = [20, 40, 80, 200, 500]\\n\" +\r\n        \"width = 0.15  # the width of the bars: can also be len(x) sequence\\n\" +\r\n        \"\\n\" +\r\n        \"#subplots是将多个图画到同一个平面上得工具,在matlab也有同样的函数\\n\" +\r\n        \"\\n\" +\r\n        \"fig, ax = plt.subplots()\\n\" +\r\n        \"ax.bar(labels, bottom_means, width, color='white', edgecolor='black', ls='-', lw=1, hatch='////', label='PFOA in water')\\n\" +\r\n        \"ax.bar(labels, top_means, width, color='white', edgecolor='black', ls='-', lw=1, yerr=top_std, bottom=bottom_means,\\n\" +\r\n        \"       hatch='xx',\\n\" +\r\n        \"       label='PFOA on SS')\\n\" +\r\n        \"#设置y轴上得标签值\\n\" +\r\n        \"ax.set_ylabel('PFOA amount (g)')\\n\" +\r\n        \"#设置图标的标题\\n\" +\r\n        \"ax.set_title('Initial PFOA concentration (mg/L)')\\n\" +\r\n        \"#设置图例，loc=location，指的是图例的位置\\n\" +\r\n        \"ax.legend(loc='upper left')\\n\" +\r\n        \"\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"### 绘制其他样式的柱形图\\n\" +\r\n        \"\\n\" +\r\n        \"* ##### 水平的条形图\\n\" +\r\n        \"\\n\" +\r\n        \"  ```python\\n\" +\r\n        \"  import matplotlib.pyplot as plt\\n\" +\r\n        \"  \\n\" +\r\n        \"  data = [5, 20, 15, 25, 10]\\n\" +\r\n        \"  \\n\" +\r\n        \"  plt.barh(range(len(data)), data)\\n\" +\r\n        \"  plt.show()\\n\" +\r\n        \"  ```\\n\" +\r\n        \"\\n\" +\r\n        \"  ![preview](https://img-blog.csdnimg.cn/img_convert/4464a1a847ac9c9b974a0cf05e56ddcf.png)\\n\" +\r\n        \"\\n\" +\r\n        \"* **正负条形图**\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"import numpy as np\\n\" +\r\n        \"import matplotlib.pyplot as plt\\n\" +\r\n        \"\\n\" +\r\n        \"a = np.array([5, 20, 15, 25, 10])\\n\" +\r\n        \"b = np.array([10, 15, 20, 15, 5])\\n\" +\r\n        \"\\n\" +\r\n        \"plt.barh(range(len(a)), a)\\n\" +\r\n        \"plt.barh(range(len(b)), -b)\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"![img](https://img-blog.csdnimg.cn/img_convert/9a96e59146eac268d4a28d68641a0c83.png)\\n\" +\r\n        \"\\n\" +\r\n        \"## 2.误差线\\n\" +\r\n        \"\\n\" +\r\n        \"#### 坐标轴参数\\n\" +\r\n        \"\\n\" +\r\n        \"1. 设置双Y坐标轴\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   ax2 = plt.twinx()\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"   ==主要通过twinx(\\t)方法创建出另一个坐标轴，此时在下面画图将会以右侧纵坐标为准==\\n\" +\r\n        \"\\n\" +\r\n        \"2. 修改坐标轴的范围\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   pyplot.ylim(ymax=400)\\n\" +\r\n        \"   pyplot.ylim(ymin=10)\\n\" +\r\n        \"   pyplot.xlim(xmax=10)\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"3. 设置坐标轴刻度的参数\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   pyplot.tick_params(which='major', direction='in', length=6)\\n\" +\r\n        \"   #可选关键字\\n\" +\r\n        \"   #可选参数which:选择major or minor\\n\" +\r\n        \"   #direction:刻度的朝向，可选in or out\\n\" +\r\n        \"   #length: 刻度的长度\\n\" +\r\n        \"   #width: 刻度的宽度\\n\" +\r\n        \"   #size : 刻度标签的大小\\n\" +\r\n        \"   #axis: 指定是纵坐标还是，横坐标，可选xaxis or yaxis\\n\" +\r\n        \"   #colors:刻度标签的颜色\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   axis.xaxis.set_minor_locator(MultipleLocator(0.25))\\n\" +\r\n        \"   #设置纵坐标或者横坐标的次纵坐标的位置，上面表示每个0.25画一个次纵坐标\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"4. 设置坐标轴颜色\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   axis.spines['bottom'].set_color('red')\\n\" +\r\n        \"   #设置坐标轴的颜色，可选参数top or bottom or left or right\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"5. 隐藏坐标轴\\n\" +\r\n        \"\\n\" +\r\n        \"   ```python\\n\" +\r\n        \"   #隐藏y轴坐标\\n\" +\r\n        \"   plt.gca().get_yaxis().set_visible(False)\\n\" +\r\n        \"   #隐藏x轴坐标\\n\" +\r\n        \"   plt.gca().get_xaxis().set_visible(False)\\n\" +\r\n        \"   ```\\n\" +\r\n        \"\\n\" +\r\n        \"#### plot方法\\n\" +\r\n        \"\\n\" +\r\n        \"* **plot([x], y, [fmt], data=None, ****kwargs**)**\\n\" +\r\n        \"\\n\" +\r\n        \"  fmt：可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle）\\n\" +\r\n        \"\\n\" +\r\n        \"  具体形式  fmt = '\\\\[color]\\\\[marker][line]'\\n\" +\r\n        \"\\n\" +\r\n        \"  参考了：[matplotlib.pyplot.plot()参数详解](https://blog.csdn.net/sinat_36219858/article/details/79800460)\\n\" +\r\n        \"\\n\" +\r\n        \"  ```pyt\\n\" +\r\n        \"  plot(x, y, 'bo-')  # 蓝色圆点实线\\n\" +\r\n        \"  ```\\n\" +\r\n        \"\\n\" +\r\n        \"  color: 线的颜色\\n\" +\r\n        \"\\n\" +\r\n        \"  marker: 点的形状\\n\" +\r\n        \"\\n\" +\r\n        \"  line: 线的形状\\n\" +\r\n        \"\\n\" +\r\n        \"  ```python\\n\" +\r\n        \"  \\t#maker的可选值\\n\" +\r\n        \"      =============    ===============================\\n\" +\r\n        \"      character        description\\n\" +\r\n        \"      =============    ===============================\\n\" +\r\n        \"      ``'.'``          point marker\\n\" +\r\n        \"      ``','``          pixel marker\\n\" +\r\n        \"      ``'o'``          circle marker\\n\" +\r\n        \"      ``'v'``          triangle_down marker\\n\" +\r\n        \"      ``'^'``          triangle_up marker\\n\" +\r\n        \"      ``'<'``          triangle_left marker\\n\" +\r\n        \"      ``'>'``          triangle_right marker\\n\" +\r\n        \"      ``'1'``          tri_down marker\\n\" +\r\n        \"      ``'2'``          tri_up marker\\n\" +\r\n        \"      ``'3'``          tri_left marker\\n\" +\r\n        \"      ``'4'``          tri_right marker\\n\" +\r\n        \"      ``'s'``          square marker\\n\" +\r\n        \"      ``'p'``          pentagon marker\\n\" +\r\n        \"      ``'*'``          star marker\\n\" +\r\n        \"      ``'h'``          hexagon1 marker\\n\" +\r\n        \"      ``'H'``          hexagon2 marker\\n\" +\r\n        \"      ``'+'``          plus marker\\n\" +\r\n        \"      ``'x'``          x marker\\n\" +\r\n        \"      ``'D'``          diamond marker\\n\" +\r\n        \"      ``'d'``          thin_diamond marker\\n\" +\r\n        \"      ``'|'``          vline marker\\n\" +\r\n        \"      ``'_'``          hline marker\\n\" +\r\n        \"      =============    ===============================\\n\" +\r\n        \"  ```\\n\" +\r\n        \"\\n\" +\r\n        \"  \\n\" +\r\n        \"\\n\" +\r\n        \"  ```python\\n\" +\r\n        \"  #line的可选值\\n\" +\r\n        \"  =============    ===============================\\n\" +\r\n        \"  character        description\\n\" +\r\n        \"  =============    ===============================\\n\" +\r\n        \"  ``'-'``          solid line style 实线\\n\" +\r\n        \"  ``'--'``         dashed line style 虚线\\n\" +\r\n        \"  ``'-.'``         dash-dot line style 点画线\\n\" +\r\n        \"  ``':'``          dotted line style 点线\\n\" +\r\n        \"  =============    ===============================\\n\" +\r\n        \"  ```\\n\" +\r\n        \"\\n\" +\r\n        \"  ==如果不选maker，那么只是直接连线==\\n\" +\r\n        \"\\n\" +\r\n        \"  * **其他关键字**\\n\" +\r\n        \"\\n\" +\r\n        \"    ```python\\n\" +\r\n        \"    lw(linewidth):线的宽度（粗细）\\n\" +\r\n        \"    c(color):线的颜色\\n\" +\r\n        \"    ls(linestyle):线的样式\\n\" +\r\n        \"    marker:折点的形状\\n\" +\r\n        \"    markeredgecolor 或 mec -- 折点外边颜色\\n\" +\r\n        \"    markeredgewidth 或 mew -- 折点线宽\\n\" +\r\n        \"    markerfacecolor 或 mfc --折点实心颜色\\n\" +\r\n        \"    markerfacecoloralt 或 mfcalt\\n\" +\r\n        \"    markersize 或 ms --折点大小\\n\" +\r\n        \"    ```\\n\" +\r\n        \"\\n\" +\r\n        \"    \\n\" +\r\n        \"\\n\" +\r\n        \"#### errorbar方法\\n\" +\r\n        \"\\n\" +\r\n        \"errorabar方法专门用来作误差线，但它无法很好的定义连线的参数，因此可以与plot方法配合使用。\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"errorbar(x, y,**kwargs)\\n\" +\r\n        \"#x,y 绘图的点\\n\" +\r\n        \"#关键字：\\n\" +\r\n        \"#xerr,yerr: 数据的误差范围\\n\" +\r\n        \"#fmt: 数据点的标记样式以及相互之间连接线样式\\n\" +\r\n        \"#ecolor: 误差棒的线条颜色\\n\" +\r\n        \"#elinewidth: 误差棒的线条粗细\\n\" +\r\n        \"#capsize: 误差棒边界横杠的大小\\n\" +\r\n        \"#capthick: 误差棒边界横杠的厚度\\n\" +\r\n        \"#ms(markersize): 数据点的大小\\n\" +\r\n        \"#mfc: 数据点的颜色\\n\" +\r\n        \"#mec: 数据点边缘的颜色\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"## 3.文字注释\\n\" +\r\n        \"#### text方法\\n\" +\r\n        \"\\n\" +\r\n        \"​\\t\\t==text方法专门用来向图表中添加文字==\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"pyplot.text(-3, 40, \\\"要添加的内容\\\"（可以使用Latex语法），**keyword)\\n\" +\r\n        \"# 可选的关键字：\\n\" +\r\n        \"# alpha 设置字体的透明度\\n\" +\r\n        \"# family 设置字体\\n\" +\r\n        \"# size 设置字体的大小\\n\" +\r\n        \"# style 设置字体的风格\\n\" +\r\n        \"# wight 字体的粗细\\n\" +\r\n        \"# bbox 给字体添加框，alpha 设置框体的透明度， facecolor 设置框体的颜色\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"#### figtext方法\\n\" +\r\n        \"\\n\" +\r\n        \" \\t\\tfigtext方法可以向图标中任意位置添加文字\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"#使用figtext()\\n\" +\r\n        \"x = np.arange(0, 2*np.pi, 0.01)\\n\" +\r\n        \"plt.plot(np.sin(x))\\n\" +\r\n        \"plt.figtext(0.5, 0.5, \\\"sin(0)=0\\\")  # 使用figtext时，x,y代表相对值，表示图片的宽高\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"#### annotate方法\\n\" +\r\n        \"\\n\" +\r\n        \"​\\t\\tannoatate方法可以添加箭头\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"plt.figure(figsize=(6, 6))\\n\" +\r\n        \"x = np.random.randint(0, 10, size=10)\\n\" +\r\n        \"x[5] = 30    # 对x中索引值为5的重新赋值\\n\" +\r\n        \"plt.plot(x)\\n\" +\r\n        \"plt.ylim([-2, 35])\\n\" +\r\n        \"# plt.annotate(text=\\\"this point is important\\\", xy=(5, 30), xytext=(6, 31),arrowprops={\\\"width\\\": 2, \\\"headlength\\\": 5, \\\"headwidth\\\": 5, \\\"shrink\\\": 0.1})\\n\" +\r\n        \"plt.annotate(s=\\\"this point is important\\\", xy=(5, 30), xytext=(6, 31),arrowprops={\\\"arrowstyle\\\":\\\"->\\\"}) \\n\" +\r\n        \"# 如果arrowprops中有arrowstyle,就不应该有其他的属性，\\n\" +\r\n        \"#xy代表的是箭头的位置，xytext代表的是箭头文本的位置。\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"#箭头参数：\\n\" +\r\n        \"#text : \\\"string\\\"\\n\" +\r\n        \"\\t\\n\" +\r\n        \"#xy: 箭头的坐标\\n\" +\r\n        \"\\t\\n\" +\r\n        \"#xytext: 文字的坐标\\n\" +\r\n        \"\\t\\n\" +\r\n        \"#arrowprops: 箭头的属性，字典类型：\\n\" +\r\n        \"#下面是箭头的属性：\\n\" +\r\n        \"#headlength:箭头头部的长度\\n\" +\r\n        \"\\n\" +\r\n        \"#headwidth:箭头头部的宽度\\n\" +\r\n        \"\\t\\n\" +\r\n        \"#facecolor：箭头颜色\\n\" +\r\n        \"\\t\\n\" +\r\n        \"#shrink:箭头的长度（两坐标距离的比例，0~1）\\n\" +\r\n        \"\\t\\n\" +\r\n        \"#width:箭头的宽度\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"==箭头的样式：==\\n\" +\r\n        \"\\n\" +\r\n        \"![在这里插入图片描述](https://img-blog.csdnimg.cn/20190930094144180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hIRzIwMTcxMjI2,size_16,color_FFFFFF,t_70)\\n\" +\r\n        \"### 其他例子\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"import numpy as np\\n\" +\r\n        \"import matplotlib.pyplot as plt\\n\" +\r\n        \"from matplotlib.ticker import MultipleLocator\\n\" +\r\n        \"# x轴坐标\\n\" +\r\n        \"x = [0, 1, 2, 5, 8, 10, 15]\\n\" +\r\n        \"# 曲线1的y轴坐标\\n\" +\r\n        \"y1 = [188, 135, 108, 80, 74, 70, 74]\\n\" +\r\n        \"# 右侧曲线y轴的缩放系数\\n\" +\r\n        \"k = 7 / 200\\n\" +\r\n        \"# 右侧曲线的y轴值\\n\" +\r\n        \"y2 = [178 * k, 125 * k, 96 * k, 65 * k, 48 * k, 38 * k, 43 * k]\\n\" +\r\n        \"y3 = [18, 15, 13, 9, 7, 5, 6]\\n\" +\r\n        \"y4 = [0, 55, 76, 110, 126, 140, 132]\\n\" +\r\n        \"# 生成子图和图像\\n\" +\r\n        \"fig, ax1 = plt.subplots()\\n\" +\r\n        \"# 绘制误差线，并用字典加以修饰\\n\" +\r\n        \"# $x^2$这是使用Latex渲染\\n\" +\r\n        \"ax1.errorbar(x, y1, yerr=7, lw=1, ecolor='k', color='k', marker='o', mfc='w', ms=10,\\n\" +\r\n        \"             capsize=3, mec='k', label=\\\"$SS$\\\")\\n\" +\r\n        \"ax1.errorbar(x, y3, yerr=7, lw=1, ecolor='k', color='k', marker='s', mfc='w', ms=7,\\n\" +\r\n        \"             capsize=3, mec='k', label=\\\"$Water$\\\")\\n\" +\r\n        \"ax1.errorbar(x, y4, yerr=7, lw=1, ecolor='k', color='k', marker='^', mfc='w', ms=10,\\n\" +\r\n        \"             capsize=3, mec='k', label=\\\"$Precipitate$\\\")\\n\" +\r\n        \"ax1.set_ylabel(\\\"PFOA amount (g)\\\", fontdict={'weight': 'bold', 'size': 13})\\n\" +\r\n        \"# 开启次坐标轴\\n\" +\r\n        \"plt.minorticks_on()\\n\" +\r\n        \"# plt.legend(frameon=False, bbox_to_anchor=(0.915, 1)\\n\" +\r\n        \"# 获取子图1的图例句柄和标签值\\n\" +\r\n        \"handles_1, labels_1 = ax1.get_legend_handles_labels()\\n\" +\r\n        \"# 设置次坐标轴的相关参数\\n\" +\r\n        \"plt.gca().get_xaxis().set_minor_locator(MultipleLocator(1))\\n\" +\r\n        \"plt.gca().get_yaxis().set_major_locator(MultipleLocator(40))\\n\" +\r\n        \"plt.gca().get_yaxis().set_minor_locator(MultipleLocator(20))\\n\" +\r\n        \"# 设置 x轴和y轴刻度的相关参数\\n\" +\r\n        \"plt.tick_params(which='minor', axis='x', direction='in')\\n\" +\r\n        \"plt.tick_params(which='minor', axis='y', direction='in')\\n\" +\r\n        \"plt.tick_params(which='major', axis='x', length=4)\\n\" +\r\n        \"plt.tick_params(which='major', axis='y', length=4)\\n\" +\r\n        \"# plt.annotate(xy=(0, 0), xytext=(14, 160), text=\\\"$y=x^2$\\\",\\n\" +\r\n        \"#              arrowprops={\\\"width\\\": 2, \\\"headlength\\\": 5, \\\"headwidth\\\": 5,\\n\" +\r\n        \"#\\n\" +\r\n        \"#                          \\\"shrink\\\": 0.05})\\n\" +\r\n        \"# 生成右侧的纵坐标，当前画图将以右侧为准\\n\" +\r\n        \"ax2 = plt.twinx()\\n\" +\r\n        \"# 设置 右侧y轴的坐标轴范围\\n\" +\r\n        \"plt.ylim(ymax=7)\\n\" +\r\n        \"line4 = plt.errorbar(x, y2, lw=1, yerr=7 * k, marker='o', mfc='b', ms=10, capsize=3, label=\\\"$Residual turbidity$\\\")\\n\" +\r\n        \"\\n\" +\r\n        \"plt.gca().get_yaxis().set_minor_locator(MultipleLocator(0.5))\\n\" +\r\n        \"# 设置右侧纵坐标的y轴参数\\n\" +\r\n        \"plt.tick_params(which='minor', axis='y', direction='in')\\n\" +\r\n        \"plt.tick_params(which='major', axis='y', length=4)\\n\" +\r\n        \"ax2.set_ylabel(\\\"Residual turbidity (NTU)\\\", fontdict={'weight': 'bold', 'color': 'blue', 'size': 13})\\n\" +\r\n        \"ax2.spines['right'].set_color('blue')\\n\" +\r\n        \"# plt.legend(frameon=False, bbox_to_anchor=(1, 0.85))\\n\" +\r\n        \"# 获得子图的图例句柄和标签值\\n\" +\r\n        \"handles_2, labels_2 = ax2.get_legend_handles_labels()\\n\" +\r\n        \"# 将两个图例合并\\n\" +\r\n        \"plt.legend(handles=handles_1 + handles_2, bbox_to_anchor=(0.1, 1))\\n\" +\r\n        \"# 绘制标题栏\\n\" +\r\n        \"plt.title(\\\"PACl dose (mg/L)\\\", fontdict={'weight': 'bold', 'size': 15})\\n\" +\r\n        \"\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"fig.savefig('p2.svg', bbox_inches='tight')\\n\" +\r\n        \"\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"```python\\n\" +\r\n        \"import kwargs as kwargs\\n\" +\r\n        \"import numpy as np\\n\" +\r\n        \"from brokenaxes import brokenaxes\\n\" +\r\n        \"from matplotlib import pyplot as plt\\n\" +\r\n        \"from matplotlib.pyplot import minorticks_on\\n\" +\r\n        \"from matplotlib.ticker import MultipleLocator\\n\" +\r\n        \"\\n\" +\r\n        \"# 此处使用numpy生成一组数列，这是x轴的值，是左闭右开的\\n\" +\r\n        \"x = np.arange(0, 25, 5)\\n\" +\r\n        \"# 设置y轴的值\\n\" +\r\n        \"y1 = [0.8, 0, 0, 0, 0]\\n\" +\r\n        \"y2 = [6.5, 2.5, 0.8, 0, 0]\\n\" +\r\n        \"y3 = [370, 90, 8.2, 1.3, 0]\\n\" +\r\n        \"# 生成图像和两个子图，第一个子图有两列，第二个子图有一列，ax1会在ax2下方显示\\n\" +\r\n        \"fig, (ax2, ax1) = plt.subplots(2, 1, sharex=True)\\n\" +\r\n        \"# 为整个图像添加一个大的子图，只是为了能够添加y轴的标题\\n\" +\r\n        \"fig.add_subplot(211, frameon=False)\\n\" +\r\n        \"# 隐藏ax1上方的坐标轴\\n\" +\r\n        \"ax1.spines['top'].set_visible(False)\\n\" +\r\n        \"# 隐藏 ax2的底部坐标轴\\n\" +\r\n        \"ax2.spines['bottom'].set_visible(False)\\n\" +\r\n        \"# 将次坐标轴打开\\n\" +\r\n        \"minorticks_on()\\n\" +\r\n        \"# 设置x轴和y轴的主次坐标轴间隔\\n\" +\r\n        \"ax1.xaxis.set_major_locator(MultipleLocator(5))\\n\" +\r\n        \"ax1.xaxis.set_minor_locator(MultipleLocator(2.5))\\n\" +\r\n        \"ax1.yaxis.set_minor_locator(MultipleLocator(2))\\n\" +\r\n        \"# 设置ax1和ax2的y轴范围\\n\" +\r\n        \"ax1.set_ylim(0, 8.5)\\n\" +\r\n        \"ax2.set_ylim(95, 400)\\n\" +\r\n        \"# 隐藏ax2的x轴刻度线\\n\" +\r\n        \"ax2.tick_params(which='both', axis='x', length=0)\\n\" +\r\n        \"# 绘制误差线\\n\" +\r\n        \"ax1.errorbar(x, y1, yerr=0.4, fmt='k-s', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\\n\" +\r\n        \"             label='0.5 mg/L PFOA')\\n\" +\r\n        \"ax2.errorbar(x, y1, yerr=0.4, fmt='k-s', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\\n\" +\r\n        \"             label='0.5 mg/L PFOA')\\n\" +\r\n        \"ax1.errorbar(x, y2, yerr=0.4, fmt='k-o', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\\n\" +\r\n        \"             label='1 mg/L PFOA')\\n\" +\r\n        \"ax2.errorbar(x, y2, yerr=0.4, fmt='k-o', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\\n\" +\r\n        \"             label='1 mg/L PFOA')\\n\" +\r\n        \"ax1.errorbar(x, y3, yerr=0.4, fmt='b-^', lw=0.8, mfc='w', ecolor='blue', mec='b', capsize=2, elinewidth=0.2, ms=7,\\n\" +\r\n        \"             label='3mg/L PFOA')\\n\" +\r\n        \"ax2.errorbar(x, y3, yerr=0.4, fmt='b-^', lw=0.8, mfc='w', ecolor='blue', mec='b', capsize=2, elinewidth=0.2, ms=7,\\n\" +\r\n        \"             label='3mg/L PFOA')\\n\" +\r\n        \"# 绘制两条斜杠，表示坐标轴之间不连续\\n\" +\r\n        \"d = 0.015\\n\" +\r\n        \"# 下面这句话是一个字典，表示以整个坐标轴的长度为单位1，颜色设为黑色\\n\" +\r\n        \"kwargs = dict(transform=ax2.transAxes, color='k', clip_on=False, lw=0.8)\\n\" +\r\n        \"ax2.plot((-d, +d), (-d, +d), **kwargs)  # top-left diagonal\\n\" +\r\n        \"\\n\" +\r\n        \"kwargs.update(transform=ax1.transAxes)  # switch to the bottom axes\\n\" +\r\n        \"ax1.plot((-d, +d), (1 - d, 1 + d), **kwargs)  # bottom-left diagonal\\n\" +\r\n        \"\\n\" +\r\n        \"ax1.plot((1, 1), (1, 1 + 20 * d), **kwargs)\\n\" +\r\n        \"\\n\" +\r\n        \"# What's cool about this is that now if we vary the distance between\\n\" +\r\n        \"# ax and ax2 via f.subplots_adjust(hspace=...) or plt.subplot_tool(),\\n\" +\r\n        \"# the diagonal lines will move accordingly, and stay right at the tips\\n\" +\r\n        \"# of the spines they are 'breaking'\\n\" +\r\n        \"ax2.legend()\\n\" +\r\n        \"# 将大子图的x轴 y轴 ,刻度线全部隐藏\\n\" +\r\n        \"plt.tick_params(labelcolor='none', top='off', bottom='off', left='off', right='off')\\n\" +\r\n        \"plt.tick_params(which='both', length=0)\\n\" +\r\n        \"\\n\" +\r\n        \"plt.title(\\\"PAC dose (mg/L)\\\", size='14', weight='bold')\\n\" +\r\n        \"fig.text(0.04, 0.5, 'PFOA in water (g/L)', size='15', weight='bold', ha='center', va='center', rotation='vertical')\\n\" +\r\n        \"\\n\" +\r\n        \"plt.show()\\n\" +\r\n        \"plt.title(\\\"PAC dose (mg/L)\\\")\\n\" +\r\n        \"# 下面表示dpi表示像素密度，当时保存为矢量图就不存在像素的概念了\\n\" +\r\n        \"fig.savefig('p3.svg', dpi=600)\\n\" +\r\n        \"\\n\" +\r\n        \"```\\n\"\r\n}","export default {\r\n    index: 2,\r\n    title: \"NIO通信\",\r\n    tag: [\"java\", \"nio\",\"net\"],\r\n    lang: \"java\",\r\n    display: \"NIO通讯模式的简单实现\\n\" +\r\n        \"为了简化过程，在写服务器时，只能读取信息；在写客户端时，只能发送信息。当局域网下双方连接上了对方的端口，即可实现双向通信。基于Selector这个选择器，在单线程下也可以实现多方通信。\\n\" +\r\n        \"\\n\" +\r\n        \"主要需要：SeverSocketChannel,SocketChannel,Selector,SelectionKey\",\r\n    content: \"## NIO通讯模式的简单实现\\n\" +\r\n        \"为了简化过程，在写服务器时，只能读取信息；在写客户端时，只能发送信息。当局域网下双方连接上了对方的端口，即可实现双向通信。基于Selector这个选择器，在单线程下也可以实现多方通信。\\n\" +\r\n        \"\\n\" +\r\n        \"主要需要：SeverSocketChannel,SocketChannel,Selector,SelectionKey\\n\" +\r\n        \"![效果图](https://img-blog.csdnimg.cn/20200822172319350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ3MjAyNTE4,size_16,color_FFFFFF,t_70#pic_center)\\n\" +\r\n        \"代码如下：\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"```java\\n\" +\r\n        \"package Message1;\\n\" +\r\n        \"import java.util.*;\\n\" +\r\n        \"import javax.swing.*;\\n\" +\r\n        \"import java.awt.*;\\n\" +\r\n        \"import java.io.IOException;\\n\" +\r\n        \"import java.net.InetSocketAddress;\\n\" +\r\n        \"import java.nio.ByteBuffer;\\n\" +\r\n        \"import java.nio.channels.SelectionKey;\\n\" +\r\n        \"import java.nio.channels.Selector;\\n\" +\r\n        \"import java.nio.channels.ServerSocketChannel;\\n\" +\r\n        \"import java.nio.channels.SocketChannel;\\n\" +\r\n        \"\\n\" +\r\n        \"/*\\n\" +\r\n        \" * @version:1.0\\n\" +\r\n        \" * @author:何老表\\n\" +\r\n        \" * @time:2020/8/22\\n\" +\r\n        \" */\\n\" +\r\n        \"public class Message1 \\n\" +\r\n        \"{\\n\" +\r\n        \"\\tpublic static void main(String[] args)\\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\tEventQueue.invokeLater(()->{\\n\" +\r\n        \"\\t\\t\\tMessageFrame frame=new MessageFrame(\\\"Message1.0\\\");\\n\" +\r\n        \"\\t\\t\\tframe.setVisible(true);\\n\" +\r\n        \"\\t\\t});\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"}\\n\" +\r\n        \"\\n\" +\r\n        \"class MessageFrame extends JFrame\\n\" +\r\n        \"{\\n\" +\r\n        \"\\tprivate JButton connectButton;\\n\" +\r\n        \"\\tprivate JButton sendButton;\\n\" +\r\n        \"\\tprivate JButton cancelButton;\\n\" +\r\n        \"\\tprivate JButton acceptButton;\\n\" +\r\n        \"\\tprivate JTextArea messages;\\n\" +\r\n        \"\\tprivate JLabel hostLabel;\\n\" +\r\n        \"\\tprivate JLabel portLabel;\\n\" +\r\n        \"\\tprivate JTextField hostField;\\n\" +\r\n        \"\\tprivate JTextField portField;\\n\" +\r\n        \"\\tprivate JTextField messageField;\\n\" +\r\n        \"\\tprivate Server server;\\n\" +\r\n        \"\\tprivate SocketChannel socketChannel=null;\\n\" +\r\n        \"\\tprivate ServerSocketChannel serverSocketChannnel=null;\\n\" +\r\n        \"\\t\\n\" +\r\n        \"\\t\\n\" +\r\n        \"\\tpublic MessageFrame(String title)\\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\tsuper(title);\\n\" +\r\n        \"\\t\\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\\n\" +\r\n        \"\\t\\tsetLayout(new BorderLayout());\\n\" +\r\n        \"\\t\\thostLabel=new JLabel(\\\"客户机IP地址：\\\");\\n\" +\r\n        \"\\t\\thostField=new JTextField(10);\\n\" +\r\n        \"\\t\\tportLabel=new JLabel(\\\"客户机端口\\\");\\n\" +\r\n        \"\\t\\tportField=new JTextField(5);\\n\" +\r\n        \"\\t\\tJPanel northPanel=new JPanel();\\n\" +\r\n        \"\\t\\tconnectButton=new JButton(\\\"连接\\\");\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tconnectButton.addActionListener(event->{\\n\" +\r\n        \"\\t\\t\\tString ip=hostField.getText().trim();\\n\" +\r\n        \"\\t\\t\\tint port =Integer.parseInt(portField.getText().trim());\\n\" +\r\n        \"\\t\\t\\tif(connect(ip,port))\\n\" +\r\n        \"\\t\\t\\t\\tmessages.append(\\\"连接成功\\\\n\\\");\\n\" +\r\n        \"\\t\\t});\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tnorthPanel.add(hostLabel,BorderLayout.NORTH);\\n\" +\r\n        \"\\t\\tnorthPanel.add(hostField,BorderLayout.NORTH);\\n\" +\r\n        \"\\t\\tnorthPanel.add(portLabel,BorderLayout.NORTH);\\n\" +\r\n        \"\\t\\tnorthPanel.add(portField,BorderLayout.NORTH);\\n\" +\r\n        \"\\t\\tnorthPanel.add(connectButton,BorderLayout.NORTH);\\n\" +\r\n        \"\\t\\tadd(northPanel,BorderLayout.NORTH);\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tmessages=new JTextArea(\\\"本机的IP地址查询DOS命令:ipconfig\\\\n\\\",20,60);\\n\" +\r\n        \"\\t\\tadd(new JScrollPane(messages),BorderLayout.CENTER);\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tacceptButton=new JButton(\\\"开启服务器\\\");\\n\" +\r\n        \"\\t\\tsendButton=new JButton(\\\"发送信息\\\");\\n\" +\r\n        \"\\t\\tcancelButton=new JButton(\\\"退出\\\");\\n\" +\r\n        \"\\t\\tmessageField=new JTextField(20);\\n\" +\r\n        \"\\t\\t\\t\\n\" +\r\n        \"\\t\\tsendButton.addActionListener(event->{\\n\" +\r\n        \"\\t\\tsendMessage();\\n\" +\r\n        \"\\t\\t});\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tacceptButton.addActionListener(event->{\\n\" +\r\n        \"\\t\\t\\tserver=new Server();\\n\" +\r\n        \"\\t\\t\\tserver.start();\\n\" +\r\n        \"\\t\\t});\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tcancelButton.addActionListener(event->\\n\" +\r\n        \"\\t\\t{\\n\" +\r\n        \"\\t\\t\\tSystem.exit(1);\\n\" +\r\n        \"\\t\\t\\t\\n\" +\r\n        \"\\t\\t});\\n\" +\r\n        \"\\t\\tJPanel southPanel=new JPanel();\\n\" +\r\n        \"\\t\\tsouthPanel.add(messageField,BorderLayout.CENTER);\\n\" +\r\n        \"\\t\\tsouthPanel.add(acceptButton,BorderLayout.SOUTH);\\n\" +\r\n        \"\\t\\tsouthPanel.add(sendButton,BorderLayout.SOUTH);\\n\" +\r\n        \"\\t\\tsouthPanel.add(cancelButton,BorderLayout.SOUTH);\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tadd(southPanel,BorderLayout.SOUTH);\\n\" +\r\n        \"\\t\\tpack();\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"\\t//判断是否可以连接成功\\n\" +\r\n        \"\\tprivate boolean connect(String ip, int port) \\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\ttry {\\n\" +\r\n        \"\\t\\t\\tsocketChannel=SocketChannel.open();\\n\" +\r\n        \"\\t\\t\\treturn socketChannel.connect(new InetSocketAddress(ip,port));\\n\" +\r\n        \"\\t\\t}catch(IOException e)\\n\" +\r\n        \"\\t\\t{\\n\" +\r\n        \"\\t\\t\\tmessages.append(\\\"连接失败：\\\"+e);\\n\" +\r\n        \"\\t\\t\\treturn false;\\n\" +\r\n        \"\\t\\t}\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\tpublic void sendMessage()\\n\" +\r\n        \"\\t\\t{\\n\" +\r\n        \"\\t\\t\\t//输入IP和端口\\n\" +\r\n        \"\\t\\t\\tString ip=hostField.getText().trim();\\n\" +\r\n        \"\\t\\t\\tint port =Integer.parseInt(portField.getText().trim());\\n\" +\r\n        \"\\t\\t\\ttry {\\n\" +\r\n        \"\\t\\t\\t\\t//创建通道，并建立连接\\n\" +\r\n        \"\\t\\t\\tsocketChannel=SocketChannel.open();\\n\" +\r\n        \"\\t\\t\\tsocketChannel.connect(new InetSocketAddress(ip,port));\\n\" +\r\n        \"\\t\\t\\t//设置为非阻塞模式\\n\" +\r\n        \"\\t\\t\\tsocketChannel.configureBlocking(false);\\n\" +\r\n        \"\\t\\t\\tString word=messageField.getText();\\n\" +\r\n        \"\\t\\t\\tif(word!=\\\"\\\"|word!=null) {\\n\" +\r\n        \"\\t\\t\\t\\t//建立缓存区\\n\" +\r\n        \"\\t\\t\\tByteBuffer writeBuffer=ByteBuffer.allocate(1024*10);\\n\" +\r\n        \"\\t\\t\\t//将输入的字符串以“UTF-”转换为数组\\n\" +\r\n        \"\\t\\t\\tbyte[] bytes=word.getBytes(\\\"UTF-8\\\");\\n\" +\r\n        \"\\t\\t\\t//将数组写入缓存区\\n\" +\r\n        \"\\t\\t\\twriteBuffer.put(bytes);\\n\" +\r\n        \"\\t\\t\\t//翻转缓存区， The limit is set to \\n\" +\r\n        \"\\t\\t\\t//the current position and then\\n\" +\r\n        \"\\t\\t\\t//the position is set to zero. If the mark is defined then it is discarded. \\n\" +\r\n        \"\\t\\t\\twriteBuffer.flip();\\n\" +\r\n        \"\\t\\t\\tsocketChannel.write(writeBuffer);\\n\" +\r\n        \"\\t\\t\\tmessages.append(\\\"You:\\\"+word+\\\"\\\\n\\\");\\n\" +\r\n        \"\\t\\t\\tmessageField.setText(\\\"\\\");\\n\" +\r\n        \"\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t}catch(IOException e)\\n\" +\r\n        \"\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\tmessages.append(\\\"发送消息时出错:\\\"+e);\\n\" +\r\n        \"\\t\\t\\t}\\n\" +\r\n        \"\\t\\t}\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t//创建服务器\\n\" +\r\n        \"\\tclass Server extends Thread\\n\" +\r\n        \"\\t{\\n\" +\r\n        \"\\t\\tprivate Selector selector=null;\\n\" +\r\n        \"\\t\\t\\n\" +\r\n        \"\\t\\t@Override\\n\" +\r\n        \"\\t\\tpublic void run()\\n\" +\r\n        \"\\t\\t{\\n\" +\r\n        \"\\t\\t\\ttry\\n\" +\r\n        \"\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t//创建可中断服务器和选择器\\n\" +\r\n        \"\\t\\t\\t\\tserverSocketChannnel=ServerSocketChannel.open();\\n\" +\r\n        \"\\t\\t\\t\\tselector=Selector.open();\\n\" +\r\n        \"\\t\\t\\t\\t//设置为非阻塞模式\\n\" +\r\n        \"\\t\\t\\t\\tserverSocketChannnel.configureBlocking(false);\\n\" +\r\n        \"\\t\\t\\t\\tint port =Integer.parseInt(messageField.getText().trim());\\n\" +\r\n        \"\\t\\t\\t\\t//键入端口\\n\" +\r\n        \"\\t\\t\\t\\tserverSocketChannnel.socket().bind(new InetSocketAddress(port),10);\\n\" +\r\n        \"\\t\\t\\t\\t//将服务器通道注册在选择器上，并设置为等待模式\\n\" +\r\n        \"\\t\\t\\t\\tserverSocketChannnel.register(selector, SelectionKey.OP_ACCEPT);\\n\" +\r\n        \"\\t\\t\\t\\tmessageField.setText(\\\"\\\");\\n\" +\r\n        \"\\t\\t\\t\\tmessages.append(\\\"服务器已经启动启动，等待新接入的客户机，本机端口为：\\\"+port+\\\"\\\\n\\\");\\n\" +\r\n        \"\\t\\t\\t\\tacceptButton.setEnabled(false);\\n\" +\r\n        \"\\t\\t\\t\\t\\n\" +\r\n        \"\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\tcatch(IOException e)\\n\" +\r\n        \"\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\tmessages.append(\\\"创建服务器过程中发生错误:\\\"+e);\\n\" +\r\n        \"\\t\\t\\t\\tmessages.append(\\\"\\\\n\\\");\\n\" +\r\n        \"\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t//死循环，轮询所有通道是否有响应\\n\" +\r\n        \"\\t\\t\\twhile(true)\\n\" +\r\n        \"\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\ttry\\n\" +\r\n        \"\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t//开始轮询\\n\" +\r\n        \"\\t\\t\\t\\t\\tselector.select();\\n\" +\r\n        \"\\t\\t\\t\\t\\t//得到所有通道的键值\\n\" +\r\n        \"\\t\\t\\t\\t\\tSet<SelectionKey> selectionKey=selector.selectedKeys();\\n\" +\r\n        \"\\t\\t\\t\\t\\tIterator<SelectionKey> it=selectionKey.iterator();\\n\" +\r\n        \"\\t\\t\\t\\t\\tSelectionKey key=null;\\n\" +\r\n        \"\\t\\t\\t\\t\\twhile(it.hasNext())\\n\" +\r\n        \"\\t\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tkey = it.next();\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t//移走，防止重复操作\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tit.remove();\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\ttry\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t\\thandleInput(selector,key);\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tcatch(IOException e)\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t\\tif(key!=null) {\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t\\t\\tkey.cancel();\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t\\tif(key.channel()!=null)\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t\\t\\tkey.channel().close();\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t\\t}\\t\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t\\t}catch(Exception e)\\n\" +\r\n        \"\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\tmessages.append(\\\"接受消息时发生错误:\\\"+e);\\n\" +\r\n        \"\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t\\t\\n\" +\r\n        \"\\t\\t\\t}\\n\" +\r\n        \"\\t\\t}\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\t\\tprivate void handleInput(Selector selector, SelectionKey key) throws IOException\\n\" +\r\n        \"\\t\\t{\\n\" +\r\n        \"\\t\\t\\tif(key.isValid())\\n\" +\r\n        \"\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t//处理刚刚建立的连接\\n\" +\r\n        \"\\t\\t\\t\\tif(key.isAcceptable())\\n\" +\r\n        \"\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t//由键值得到相应服务器\\n\" +\r\n        \"\\t\\t\\t\\t\\tServerSocketChannel ssc=(ServerSocketChannel)key.channel();\\n\" +\r\n        \"\\t\\t\\t\\t\\t//得到套间字\\n\" +\r\n        \"\\t\\t\\t\\t\\tSocketChannel sc=ssc.accept();\\n\" +\r\n        \"\\t\\t\\t\\t\\t//设置为非阻塞模式\\n\" +\r\n        \"\\t\\t\\t\\t\\tsc.configureBlocking(false);\\n\" +\r\n        \"\\t\\t\\t\\t\\t//在选择器上注册为可读的\\n\" +\r\n        \"\\t\\t\\t\\t\\tsc.register(selector, SelectionKey.OP_READ);\\n\" +\r\n        \"\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t\\tif(key.isReadable())\\n\" +\r\n        \"\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\tSocketChannel channel=(SocketChannel)key.channel();\\n\" +\r\n        \"\\t\\t\\t\\t\\tByteBuffer readBuffer=ByteBuffer.allocate(1024*10);\\n\" +\r\n        \"\\t\\t\\t\\t\\tint readBytes=channel.read(readBuffer);\\n\" +\r\n        \"\\t\\t\\t\\t\\tif(readBytes>0)\\n\" +\r\n        \"\\t\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\treadBuffer.flip();\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tbyte[] bytes=new byte[readBuffer.remaining()];\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\treadBuffer.get(bytes);\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tString word=new String(bytes,\\\"UTF-8\\\");\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tmessages.append(\\\"Others:\\\"+word+\\\"\\\\n\\\");\\n\" +\r\n        \"\\t\\t\\t\\t\\t}else if(readBytes<0)\\n\" +\r\n        \"\\t\\t\\t\\t\\t{\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tkey.cancel();\\n\" +\r\n        \"\\t\\t\\t\\t\\t\\tsocketChannel.close();\\n\" +\r\n        \"\\t\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t\\t\\telse ;\\n\" +\r\n        \"\\t\\t\\t\\t}\\n\" +\r\n        \"\\t\\t\\t}\\n\" +\r\n        \"\\t\\t}\\n\" +\r\n        \"\\t}\\n\" +\r\n        \"}\\n\" +\r\n        \"```\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"\\n\" +\r\n        \"![效果图](https://img-blog.csdnimg.cn/20200822173430888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ3MjAyNTE4,size_16,color_FFFFFF,t_70#pic_center)\\n\" +\r\n        \"赶快拿回去试一下吧！\"\r\n}","import a0 from './catalog/0.js'\r\nimport a1 from './catalog/1.js'\r\nimport a2 from './catalog/2.js'\r\nconst articleList = []\r\narticleList.push(a0)\r\narticleList.push(a1)\r\narticleList.push(a2)\r\nexport default articleList"],"sourceRoot":""}